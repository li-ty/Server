### 浮点数运算精度问题处理
``` js
Math.add = function(v1, v2)
{
///<summary>精确计算加法。语法：Math.add(v1, v2)</summary>
///<param name="v1" type="number">操作数。</param>
///<param name="v2" type="number">操作数。</param>
///<returns type="number">计算结果。</returns>
    var r1, r2, m;
    try
    {
        r1 = v1.toString().split(".")[1].length;//第1个加数的小数的位数
    }
    catch (e)
    {
        r1 = 0;
    }
    try
    {
        r2 = v2.toString().split(".")[1].length;//第2个加数的小数的位数
    }
    catch (e)
    {
        r2 = 0;
    }
    m = Math.pow(10, Math.max(r1, r2));//小数位数最多的

    return (v1 * m + v2 * m) / m;//整数运算再还原
}


Number.prototype.add = function(v)
{
///<summary>精确计算加法。语法：number1.add(v)</summary>
///<param name="v" type="number">操作数。</param>
///<returns type="number">计算结果。</returns>
    return Math.add(v, this);
}


Math.sub = function(v1, v2)
{
///<summary>精确计算减法。语法：Math.sub(v1, v2)</summary>
///<param name="v1" type="number">操作数。</param>
///<param name="v2" type="number">操作数。</param>
///<returns type="number">计算结果。</returns>
    return Math.add(v1, -v2);//减法是带负号的加法运算
}


Number.prototype.sub = function(v)
{
///<summary>精确计算减法。语法：number1.sub(v)</summary>
///<param name="v" type="number">操作数。</param>
///<returns type="number">计算结果。</returns>
    return Math.sub(this, v);
}


Math.mul = function(v1, v2)
{
///<summary>精确计算乘法。语法：Math.mul(v1, v2)</summary>
///<param name="v1" type="number">操作数。</param>
///<param name="v2" type="number">操作数。</param>
///<returns type="number">计算结果。</returns>
    var m = 0;
    var s1 = v1.toString();
    var s2 = v2.toString();
    try
    {
        m += s1.split(".")[1].length;
    }
    catch (e)
    {
    }
    try
    {
        m += s2.split(".")[1].length;
    }
    catch (e)
    {
    }

    return Number(s1.replace(".", "")) * Number(s2.replace(".", "")) / Math.pow(10, m);
}


Number.prototype.mul = function(v)
{
///<summary>精确计算乘法。语法：number1.mul(v)</summary>
///<param name="v" type="number">操作数。</param>
///<returns type="number">计算结果。</returns>
    return Math.mul(v, this);
}


Math.div = function(v1, v2)
{
///<summary>精确计算除法。语法：Math.div(v1, v2)</summary>
///<param name="v1" type="number">操作数。</param>
///<param name="v2" type="number">操作数。</param>
///<returns type="number">计算结果。</returns>
    var t1 = 0;
    var t2 = 0;
    var r1, r2;
    try
    {
        t1 = v1.toString().split(".")[1].length;
    }
    catch (e)
    {
    }
    try
    {
        t2 = v2.toString().split(".")[1].length;
    }
    catch (e)
    {
    }

    with (Math)
    {
        r1 = Number(v1.toString().replace(".", ""));
        r2 = Number(v2.toString().replace(".", ""));
        return (r1 / r2) * pow(10, t2 - t1);
    }
}


Number.prototype.div = function(v)
{
///<summary>精确计算除法。语法：number1.div(v)</summary>
///<param name="v" type="number">操作数。</param>
///<returns type="number">计算结果。</returns>
    return Math.div(this, v);
}
```

### 分组求和函数：
``` js
      function GroupBy(datas,keys,callBack) {
          const list = datas || [];
          const groups = [];
          list.forEach(v => {
              const key = {};
              const data = {};
              keys.forEach(k => {
                  key[k] = v[k];
              });
              let group = groups.find(v => {
                  return v._key === JSON.stringify(key);
              });
              if (!group) {
                  group = {
                      _key:JSON.stringify(key),
                      key: key,
                  };
                  groups.push(group);
              }
              if(callBack){
                  group.data = callBack(group.data,v);
                  group.total=group.total||0;
                  group.total++;
              }else {
                  group.data=group.data||[];
                  group.data.push(v);
              }
          });
          return groups;
      }
```
测试函数
``` js
        window.onload=function () {
            const data = [
                {key:1,key2:1,v:123},
                {key:1,key2:1,v:55},
                {key:2,key2:1,v:85},
                {key:1,key2:2,v:15},
                {key:2,key2:1,v:99}
            ];
            var d = GroupBy(data,['key','key2'],(d,v)=> {
                d = d||0;
                return d+=v.v;
            });
            console.log(d);
            var a = GroupBy(data,['key','key2']);
            console.log(a);
        };
```

### 数组排序
#### 原型链方法调用
``` js
var arr = [1, 7, 9, 8, 3, 2, 6, 0, 5, 4];
arr.sort((a,b) => a-b); // arr.__proto__.sort
console.log(arr); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

#### 简单选择排序
``` js
var arr = [1, 7, 9, 8, 3, 2, 6, 0, 5, 4];
var n = arr.length;
for(let i=0; i<n; ++i){
    let minIndex = i;
    for(let k=i+1; k<n; ++k){
        if(arr[k] < arr[minIndex]) minIndex = k;
    }
    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
}
console.log(arr); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
// 平均时间复杂度 O(n²) 最好情况 O(n²) 最坏情况 O(n²) 空间复杂度 O(1) 不稳定排序
```
#### 冒泡排序
``` js
var arr = [1, 7, 9, 8, 3, 2, 6, 0, 5, 4];
var n = arr.length;
for(let i=0; i<n; ++i){
    let swapFlag = false;
    for(let k=0; k<n-i-1; ++k){
        if(arr[k] > arr[k+1]) {
            swapFlag = true;
            [arr[k], arr[k+1]] = [arr[k+1], arr[k]];
        }
    }
    if(!swapFlag) break;
}
console.log(arr); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
// 平均时间复杂度 O(n²) 最好情况 O(n) 最坏情况 O(n²) 空间复杂度 O(1) 稳定排序
```
#### 插入排序
``` js
var arr = [1, 7, 9, 8, 3, 2, 6, 0, 5, 4];
var n = arr.length;
for(let i=1; i<n; ++i){
    let preIndex = i-1;
    let current = arr[i];
    while(preIndex >= 0 && arr[preIndex] > current) {
        arr[preIndex+1] = arr[preIndex];
        --preIndex;
    }
    arr[preIndex+1] = current;
}
console.log(arr); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
// 平均时间复杂度 O(n²) 最好情况 O(n) 最坏情况 O(n²) 空间复杂度 O(1) 稳定排序
```
#### 快速排序
``` js
function partition(arr, start, end){
    var boundary = arr[start];
    while(start < end){
        while(start < end && arr[end] >= boundary) --end;
        arr[start] = arr[end];
        while(start < end && arr[start] <= boundary) ++start;
        arr[end] = arr[start];
    }
    arr[start] = boundary;
    return start;
}

function quickSort(arr, start, end){
    if(start >= end) return ;
    var boundaryIndex = partition(arr, start, end);
    quickSort(arr, start, boundaryIndex-1);
    quickSort(arr, boundaryIndex+1, end);
}


var arr = [1, 7, 9, 8, 3, 2, 6, 0, 5, 4];
quickSort(arr, 0, arr.length-1);
console.log(arr); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
// 平均时间复杂度 O(nlogn) 最好情况 O(nlogn) 最坏情况 O(n²) 空间复杂度 O(logn) 不稳定排序
```
#### 希尔排序
``` js
function shellSort(arr){
    var n = arr.length;
    for(let gap=n/2; gap>0; gap=Math.floor(gap/2)){
        for(let i=gap; i<n; ++i){
            for(let k=i-gap; k>=0 && arr[k]>arr[k+gap]; k=k-gap){
                [arr[k], arr[k+gap]] = [arr[k+gap], arr[k]];
            }
        }
    }
}

var arr = [1, 7, 9, 8, 3, 2, 6, 0, 5, 4];
shellSort(arr);
console.log(arr); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
// 平均时间复杂度 O(nlogn) 最好情况 O(nlog²n) 最坏情况 O(nlog²n) 空间复杂度 O(1) 不稳定排序
```
#### 堆排序
``` js
function adjustHeap(arr, i, n) {
    for(let k=2*i+1; k<n; k=2*k+1){
        let parent = arr[i];
        if(k+1 < n && arr[k] < arr[k+1]) ++k;
        if(parent < arr[k]){
            [arr[i], arr[k]] = [arr[k], arr[i]];
            i = k;
        }else{
            break;
        }
    }
}

function heapSort(arr) {
    var n = arr.length;
    for(let i = Math.floor(n/2-1); i>=0; --i) adjustHeap(arr, i, n);
    for(let i=n-1; i>0; --i){
        [arr[0], arr[i]] = [arr[i], arr[0]];
        adjustHeap(arr, 0, i);
    }
}

var arr = [1, 7, 9, 8, 3, 2, 6, 0, 5, 4];
heapSort(arr);
console.log(arr); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
// 平均时间复杂度 O(nlogn) 最好情况 O(nlogn) 最坏情况 O(nlogn) 空间复杂度 O(1) 不稳定排序
```
#### 归并排序
``` js
function merger(arr, start, mid, end, auxArr){
    var startStroage = start;
    var midRight = mid + 1;
    var count = 0;
    while(start <= mid && midRight <= end){
        if(arr[start] <= arr[midRight]) auxArr[count++] = arr[start++];
        else auxArr[count++] = arr[midRight++];
    }
    while(start<=mid) auxArr[count++] = arr[start++];
    while(midRight<=end) auxArr[count++] = arr[midRight++];
    for(let i=0; i<count; ++i) arr[i+startStroage] = auxArr[i];
    return arr;
}

function mergeSort(arr, start, end, auxArr) {
  if(start<end) {
    var mid = Math.floor((start+end)/2);
    var left = mergeSort(arr, start, mid, auxArr); 
    var right = mergeSort(arr, mid+1, end, auxArr); 
    arr = merger(arr, start, mid, end, auxArr);  
  }
  return arr;
}

var arr = [1, 7, 9, 8, 3, 2, 6, 0, 5, 4];
arr = mergeSort(arr, 0, arr.length-1, []);
console.log(arr); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
// 平均时间复杂度 O(nlogn) 最好情况 O(nlogn) 最坏情况 O(nlogn) 空间复杂度 O(n) 稳定排序
```
